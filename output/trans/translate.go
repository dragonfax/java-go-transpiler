package trans

import (
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"strings"

	"github.com/antlr/antlr4/runtime/Go/antlr"
	"github.com/aymerick/raymond"
	"github.com/dragonfax/java_converter/input/ast"
	"github.com/dragonfax/java_converter/input/listen"
	"github.com/dragonfax/java_converter/input/parser"
	"github.com/dragonfax/java_converter/tool"
)

const golangTemplateFilename = "output/templates/golang.tmpl"

var lexer = parser.NewJavaLexer(nil)
var p = parser.NewJavaParser(nil)

func init() {
	parser.RuleNames = p.RuleNames
}

var golangTemplate = tool.MustByteListErr(ioutil.ReadFile(golangTemplateFilename))

func parseAST(path string) *ast.File {

	stackListener := listen.NewStackListener()

	fileListener := listen.NewFileListener(stackListener, path)
	stackListener.Push(fileListener)

	input, _ := antlr.NewFileStream(path)
	lexer.SetInputStream(input)
	stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)
	p.SetInputStream(stream)
	// p.AddErrorListener(antlr.NewDiagnosticErrorListener(true))
	p.BuildParseTrees = true
	antlr.ParseTreeWalkerDefault.Walk(stackListener, p.CompilationUnit())

	if stackListener.Len() != 1 {
		if stackListener.Len() == 2 {
			panic(fmt.Sprintf("left over listener %T", stackListener.Peek()))
		}
		panic("wrong number of listeners left over, " + fmt.Sprintf("%d", stackListener.Len()))
	}

	/*
		js, err := json.MarshalIndent(p.CompilationUnit(), "", "  ")
		if err != nil {
			panic(err)
		}
	*/
	// fmt.Println(p.CompilationUnit().ToStringTree())

	return fileListener.File
}

func dumpAST(file *ast.File) {
	js, err := json.MarshalIndent(file, "", "  ")
	if err != nil {
		panic(err)
	}
	fmt.Println(string(js))
}

// input filename to go-code string
func TranslateFile(filename string) string {

	goAST := parseAST(filename)

	dumpAST(goAST)

	goCode := generateGo(goAST)

	goCode = goFmt(goCode)

	return goCode
}

// input filename to output filename
func TranslateFiles(filename, targetFilename string) {
	goCode := TranslateFile(filename)
	outputFile(targetFilename, goCode)
}

func outputFile(filename, code string) {
	err := ioutil.WriteFile(filename, []byte(code), 0640)
	if err != nil {
		panic(err)
	}
}

func generateGo(file *ast.File) string {
	result, err := raymond.Render(string(golangTemplate), file)
	if err != nil {
		panic(err)
	}
	return result
}

func goFmt(t string) string {
	// reformat output as proper go.
	wr := strings.Builder{}
	// wr.WriteString("/* AUTOGENERATED -- DO NOT EDIT */\n")
	wr.WriteString(t)
	genSource := wr.String()
	source, err := format.Source([]byte(genSource))
	if err != nil {
		// report err, show generated and unformated source

		// add line numbers to source output
		os.Stderr.WriteString(fmt.Sprintf("\nerror formating source: %s\n\n", err))
		lineNumberWriter := newLineNumberWriter(os.Stderr)
		lineNumberWriter.WriteString(string(genSource))
		os.Stderr.WriteString("\n\n")

		panic(err)
	}

	return string(source)
}
